#include "SobelEdgeWidget.h"

SobelEdgeWidget::SobelEdgeWidget(QWidget* parent)
{
    // Waveform correction files are files that correct for abberations in the Liquid Crystal display that are specific
    //      to each individual SLM and are generated by the manufacturer
    // 
    // Currently the SLM that we have in the EE West lab is only 1920x1152, thus we only have access to a 1920x1152 WFC file
    // 
    // You will have to adjust the filepath in the loadWFC function to point to your WFC file.
    // Make sure the WFC image is put within the WFCfiles folder
    height = Get_Height();
    width = Get_Width();
    depth = Get_Depth();

    //Start the Hologram Generatator within the Widget
    Initialize_HologramGenerator(width, height, depth, 10, true);

    //Make sure that the Widget can hold both the sliders and the Edge Image
    setMinimumSize(SobelWidgetW, SobelWidgetH);

    //This Layout will hold the Slider widget on the left and the Edge image on the right
    QHBoxLayout* entireWidgetLayout = new QHBoxLayout(this);


    // Sliders subWidget-----------------------------------------------------------------

   // Create the sliders and add them to a vertical layout
    QVBoxLayout* sliderLayout = new QVBoxLayout();
    xSlider = new QSlider(Qt::Horizontal);
    ySlider = new QSlider(Qt::Horizontal);
    ksizeSlider = new QSlider(Qt::Horizontal);
    sliderLayout->addWidget(new QLabel("X"));
    sliderLayout->addWidget(xSlider);
    sliderLayout->addWidget(new QLabel("Y"));
    sliderLayout->addWidget(ySlider);
    sliderLayout->addWidget(new QLabel("Kernel size"));
    sliderLayout->addWidget(ksizeSlider);

    // Set the range and initial values for the sliders
    xSlider->setRange(1, 5);
    ySlider->setRange(1, 5);
    ksizeSlider->setRange(0, 3); //3 ,5 ,7
    xSlider->setValue(1);
    ySlider->setValue(1);
    ksizeSlider->setValue(0);

    xSlider->setMaximumSize(200, 30);
    ySlider->setMaximumSize(200, 30);
    ksizeSlider->setMaximumSize(200, 30);
    sliderLayout->setAlignment(Qt::AlignTop);

    //Add sliders to the Horizontal Layout
    entireWidgetLayout->addLayout(sliderLayout);

    //output image subWidget ---------------------------------------------------------------------------------
    QVBoxLayout* outputLayout = new QVBoxLayout();
    QLabel* ouputTitleLabel = new QLabel("Edges of Hologram", this);
    outputLabel = new QLabel(this);
    CreateImageWidget(ouputTitleLabel, outputLayout, outputLabel);
    entireWidgetLayout->addLayout(outputLayout);


    // Connect the slider signals to the updateImage slot
    connect(xSlider, &QSlider::valueChanged, this, &SobelEdgeWidget::updateImage);
    connect(ySlider, &QSlider::valueChanged, this, &SobelEdgeWidget::updateImage);
    connect(ksizeSlider, &QSlider::valueChanged, this, &SobelEdgeWidget::updateImage);
    connect(this, &SobelEdgeWidget::image_loaded, this, &SobelEdgeWidget::updateImage);
    connect(this, &SobelEdgeWidget::edgeImage, this, &SobelEdgeWidget::createHologram);
}


SobelEdgeWidget::~SobelEdgeWidget()
{   
    //Releases the Hologram Generator
    Destruct_HologramGenerator();

    //Only release these arrays if they ahve been initialized
    if (num_spots != NULL)
    {
        //Releases the WFC that was loaded for Hollogram Generator
        delete[] WFC;
        //Release the arrays that held the x,y,z locations and Intensities of each focal poitns
        delete[] X_spots;
        delete[] Y_spots;
        delete[] Z_spots;
        delete[] I_spots;
    }
}


//Based on the adjust slider information, adjust the EdgeImage, display it, and send it to the hologram generator
void SobelEdgeWidget::updateImage()
{
    //If the image path passed is invalid, do not continue the process
    if (imageFromPath.empty()) return;

    // Get the slider values
    int x = xSlider->value();
    int y = ySlider->value();
    int ksize = ksizeSlider->value();

    //If the x or y value selected is graeater than 1/2 of the width/height of the kernal,
    //  it adjust the kernal to accomodate for the increased x or y desire
    //This loop also adjusts the value on the widget for the user to see
    if (x - ksize >= 3 || y - ksize >= 3)
    {   //Depending on hich is larger the kernal size will be adjusted to the larger parameter
        if (x > y) {
            ksize = x - 2;
            ksizeSlider->setValue(ksize);
        }
        else {
            ksize = y - 2;
            ksizeSlider->setValue(ksize);
        }
    }

    // Apply the Sobel filter to the input image
    cv::Mat sobelX, sobelY, sobelXY;
    cv::Sobel(imageFromPath, sobelX, CV_8U, x, 0, ksize * 2 + 3);
    cv::Sobel(imageFromPath, sobelY, CV_8U, 0, y, ksize * 2 + 3);
    cv::addWeighted(sobelX, 0.5, sobelY, 0.5, 0, sobelXY);

    //Convert the Edge image to RGB
    cv::Mat temp_rgb;
    cv::cvtColor(sobelXY, temp_rgb, cv::COLOR_GRAY2RGB);

    // Convert the processed image to a QImage and display it
    QImage image = mat2Qimage(temp_rgb);
    outputLabel->setPixmap(QPixmap::fromImage(image.scaled(200, 200, Qt::KeepAspectRatio)));

    //Ensure the edge image is the same size as the SLM display so the Hollogram generator can accuratly create the hologram
    QImage imageHoloSize = image.scaled(width, height);
    emit edgeImage(imageHoloSize);
}


//This releases the old image loaded from memory, loads a new image from the string, and emits it to the rest of the software
void SobelEdgeWidget::loadImage(QString imagePath)
{
    //Release previous image's memory
    if (!imageFromPath.empty()) imageFromPath.release();

    //Load the image in grayscale
    std::string pathStr = imagePath.toStdString();
    imageFromPath = cv::imread(pathStr.c_str(), cv::IMREAD_GRAYSCALE);

    //emit the loaded image to update it in the Widget
    emit image_loaded();
}


//This function generates the Hollogram from the Edge image, writes it to the SLM, and emits it to another widget to show it to the user
void SobelEdgeWidget::createHologram(QImage qimage)
{   QImage patternQImage;


    //Create or Recreate the array used to store the hologram
    refreshHologramArray();

    //Based on the Edge image, creates arrays containing their pixel information
    generateArrays(qimage);

    //Load the WFC image for the Hologram Generator
    loadWFC();
    
    //Generate the Hologram and send it to the SLM
    Generate_Hologram(hologramArray, WFC, X_spots, Y_spots, Z_spots, I_spots, num_spots, false); 
    Write_image(hologramArray, false);

    //From the generated hologram pattern, create a QImage to be displayed to the user
    patternQImage = array2Qimage();

    //Send the converted pattern QImage to the display widget
    emit  holoPattern(patternQImage);
}

//Converts an array into a QImage 
QImage SobelEdgeWidget::array2Qimage()
{
    // Create a RGBA8888 QImage from the pixel data
    QImage image(hologramArray, width, height, QImage::Format_RGBA8888);
    return image;
}
//Converts a cv::Mat into a RGB QImage
QImage SobelEdgeWidget::mat2Qimage(cv::Mat mat)
{
    //Converts the Mat object to the 24-bit RGB color format of QImage
    QImage qimage(mat.data, mat.cols, mat.rows, mat.step, QImage::Format_RGB888);
    return qimage;
}


//Creates the image display portion of this widget
void SobelEdgeWidget::CreateImageWidget(QLabel* titleLabel, QVBoxLayout* displayLayout, QLabel* BoxLabel) {
    //Make sure the widget puts subwidgets towards its top
    displayLayout->setAlignment(Qt::AlignTop);

    //The text itself will be centered
    titleLabel->setAlignment(Qt::AlignCenter);
    // set margin and padding to 0
    titleLabel->setStyleSheet("margin: 0px; padding: 0px;");

    //Add title subwidget to the overall widget
    displayLayout->addWidget(titleLabel);
    // set spacing between title and box
    displayLayout->setSpacing(1);
    // set margin to 0
    displayLayout->setContentsMargins(0, 0, 0, 0);

    //The image box will allign the image at its center
    BoxLabel->setAlignment(Qt::AlignCenter);
    //Create a black line to show where image will be
    BoxLabel->setStyleSheet("border: 2px solid black;");
    //The display will be 200x200 pixels
    BoxLabel->setMinimumHeight(200);
    BoxLabel->setMidLineWidth(200);
    //Add the Image box to the overall widget
    displayLayout->addWidget(BoxLabel);
}


//loads the WaveFront correction file and puts it within an array
void SobelEdgeWidget::loadWFC() {

    //Get the current directory of the executable
    std::filesystem::path currentDirectory = std::filesystem::current_path();
    //Load WFC from WFCfiles folder
    std::string WFCpath = (currentDirectory.string() + "\\WFCfiles\\slm4907.bmp");
    //This is an example of different .bmp files you can use, that would be provided with your MeadowLark SLM
    //std::string WFCpath = (currentDirectory.string() + "\\WFCfiles\\black.bmp");
    //Further explanation of why this is here is in the constructor
    
    //load WFC as a BGR image
    //The reason this is resized is so that regardless of what SLM the WFC file is made for, it can be used when code runs
    // and the SLM is not connected. Further explanation is in the constructor.
    cv::Mat temp_wfcM = cv::imread(WFCpath);
    cv::Mat wfcM;
    cv::resize(temp_wfcM, wfcM, cv::Size(width, height));

    //convert BGRimage to BGRA
    cv::Mat imgBgra;
    cv::cvtColor(wfcM, imgBgra, cv::COLOR_BGR2BGRA);

    //Make a blank channel will all 1's to repsent full opacity
    cv::Mat alpha = cv::Mat::ones(imgBgra.rows, imgBgra.cols, CV_8UC1) * 255;
    //split the BGRA image into 4 channels
    cv::Mat bgraChannels[4];
    cv::split(imgBgra, bgraChannels);
    //overwrite the alpahchannel to full opacity
    bgraChannels[3] = alpha;
    //merge the 4 channels back into one cv::MAT
    cv::merge(bgraChannels, 4, imgBgra);
     //convert BGRA to RGBA
    cv::Mat wfcRgba;
    cv::cvtColor(imgBgra, wfcRgba, cv::COLOR_BGRA2RGBA);


    int widthW = wfcRgba.cols;
    int heightW = wfcRgba.rows;
    WFC = new unsigned char[widthW * heightW * 4];
    //create an unsigned char pointer at the first memeory locastion of the Mat variable
    uchar* pixels = wfcRgba.ptr<uchar>(0);
    //populate WFC with the Mat pixels
    for (int y = 0; y < heightW; y++) {
        for (int x = 0; x < widthW; x++) {
            int index = (y * widthW + x) * 4;
            WFC[index] = pixels[index];
            WFC[index + 1] = pixels[index + 1];
            WFC[index + 2] = pixels[index + 2];
            WFC[index + 3] = pixels[index + 3];
        }
    }
}


//Creates and empties if needed the Hologram generator
void SobelEdgeWidget::refreshHologramArray() {
    //Keeps track if a previous hologramArray has been created
    static bool first = true;

    //if a hologramArray has already been created, release it 
    if (first != true) delete[] hologramArray;
    else first = false;

    //create a new array to be pointed to of the appropriate size for and RGBA image
    hologramArray = new unsigned char[width * height * 4];
}

//Based on the Edge image, creates arrays containing their pixel information
void SobelEdgeWidget::generateArrays(QImage qimage) {

    //keeps track if these arrays ahve been created or not
    static bool first = true;
    //If the image isnt grayscale use the below code
    QImage GrayQImage = qimage.convertToFormat(QImage::Format_Grayscale8);
    // Define the oversized arrays for the point data, that could hold the entire image
    float* x_spotsT = new float[GrayQImage.width() * GrayQImage.height()]; 
    float* y_spotsT = new float[GrayQImage.width() * GrayQImage.height()]; 

    // Initialize counters for the point arrays
    num_spots = 0;

    //All of the coordinates for the hologram generator are given in relation to the center pixel
    float x_offset = width / 2;
    float y_offset = height / 2;

    // Iterate over each pixel in the image
    for (int y = 0; y < GrayQImage.height(); y++) {
        for (int x = 0; x < GrayQImage.width(); x++) {
            
            // Get the RGB value of the pixel
            QRgb pixel = GrayQImage.pixel(x, y);

            // Convert the RGB value to grayscale intensity (0-255)
            int intensity = qGray(pixel);

            // Check if the pixel is non-black
            if (intensity > 0) {

                // Add the location to the point arrays
                x_spotsT[num_spots] = x - x_offset;
                y_spotsT[num_spots] = y - y_offset;

                // Increment the counter for the point arrays
                num_spots++;
            }
        }
    }
    
    //If these arrays have been created before, release their memory
    if (first == false) {
        delete[] X_spots;
        delete[] Y_spots;
        delete[] Z_spots;
        delete[] I_spots;

    }
    else first = false;

    //num_spots has the number of non-black pixels and creates arrays of appropriate size to hold that information
    // now iterate through every non-black point found
      
    //The hologram generator can only work with 1000 focal points, thus down sampling must be done instead 
    //  if there are more than 1000 points
    if (num_spots > maxFocalPnts) {
        //Downsample rate will be the number of pixels skipped between those used for the hologram generator
        int downSampleRate = num_spots / maxFocalPnts;

        //create arrays all 1000 elements long
        X_spots = new float[maxFocalPnts];
        Y_spots = new float[maxFocalPnts];
        Z_spots = new float[maxFocalPnts];
        I_spots = new float[maxFocalPnts];

        //reset this member function to only be as long as maxFocalPnts
        num_spots = 0;
        for (int i = 0; i < maxFocalPnts; i++) {

            // Add the location and intensity data to the point arrays
            X_spots[i] = x_spotsT[i * downSampleRate];
            Y_spots[i] = y_spotsT[i * downSampleRate];
            Z_spots[i] = 0;  // set to 0 for simplicity as there is no z axis
            I_spots[i] = 1; //All edge pixels are of the same intensity
            num_spots++; 
        }
    }
    //If there are less than 1000 points in the image, then create arrays of that numbers length and populate them
    else {
        //Create appropriatly sized arrays
        X_spots = new float[num_spots];
        Y_spots = new float[num_spots];
        Z_spots = new float[num_spots];
        I_spots = new float[num_spots];

        //copy data from the temperary arrays to the new correct sizes arrays
        memcpy(X_spots, x_spotsT, num_spots * sizeof(float));
        memcpy(Y_spots, y_spotsT, num_spots * sizeof(float));

        // set to 0 for simplicity as there is no z axis
        for (int n = 0; n < num_spots; n++) Z_spots[n] = 0;
        //All edge pixels are of the same intensity
        for (int n = 0; n < num_spots; n++) I_spots[n] = 1;
    }

    //release memory used for the oversized location arrays
    delete[] x_spotsT;
    delete[] y_spotsT;
}




